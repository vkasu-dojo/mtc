/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confluence

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type PageApi interface {

	/*
		CreatePage Create page

		Creates a page in the space.

	Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the corresponding space. Permission to create a page in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreatePageRequest
	*/
	CreatePage(ctx context.Context) ApiCreatePageRequest

	// CreatePageExecute executes the request
	//  @return Page
	CreatePageExecute(r ApiCreatePageRequest) (*Page, *http.Response, error)

	/*
		DeletePage Delete page

		Delete a page by id.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the page and its corresponding space. Permission to delete pages in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the page to be deleted.
		@return ApiDeletePageRequest
	*/
	DeletePage(ctx context.Context, id int64) ApiDeletePageRequest

	// DeletePageExecute executes the request
	DeletePageExecute(r ApiDeletePageRequest) (*http.Response, error)

	/*
		GetLabelPages Get pages for label

		Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the label for which pages should be returned.
		@return ApiGetLabelPagesRequest
	*/
	GetLabelPages(ctx context.Context, id int64) ApiGetLabelPagesRequest

	// GetLabelPagesExecute executes the request
	//  @return MultiEntityResultPage
	GetLabelPagesExecute(r ApiGetLabelPagesRequest) (*MultiEntityResultPage, *http.Response, error)

	/*
		GetPageById Get page by id

		Returns a specific page.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the page and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the page to be returned. If you don't know the page ID, use Get pages and filter the results.
		@return ApiGetPageByIdRequest
	*/
	GetPageById(ctx context.Context, id int64) ApiGetPageByIdRequest

	// GetPageByIdExecute executes the request
	//  @return Page
	GetPageByIdExecute(r ApiGetPageByIdRequest) (*Page, *http.Response, error)

	/*
		GetPages Get pages

		Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to access the Confluence site ('Can use' global permission).
	Only pages that the user has permission to view will be returned.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetPagesRequest
	*/
	GetPages(ctx context.Context) ApiGetPagesRequest

	// GetPagesExecute executes the request
	//  @return MultiEntityResultPage
	GetPagesExecute(r ApiGetPagesRequest) (*MultiEntityResultPage, *http.Response, error)

	/*
		GetPagesInSpace Get pages in space

		Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
	Only pages that the user has permission to view will be returned.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the space for which pages should be returned.
		@return ApiGetPagesInSpaceRequest
	*/
	GetPagesInSpace(ctx context.Context, id int64) ApiGetPagesInSpaceRequest

	// GetPagesInSpaceExecute executes the request
	//  @return MultiEntityResultPage
	GetPagesInSpaceExecute(r ApiGetPagesInSpaceRequest) (*MultiEntityResultPage, *http.Response, error)

	/*
		UpdatePage Update page

		Update a page by id.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the page and its corresponding space. Permission to update pages in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results.
		@return ApiUpdatePageRequest
	*/
	UpdatePage(ctx context.Context, id int64) ApiUpdatePageRequest

	// UpdatePageExecute executes the request
	//  @return Page
	UpdatePageExecute(r ApiUpdatePageRequest) (*Page, *http.Response, error)
}

// PageApiService PageApi service
type PageApiService service

type ApiCreatePageRequest struct {
	ctx                   context.Context
	ApiService            PageApi
	createPageRequest     *CreatePageRequest
	serializeIdsAsStrings *bool
}

func (r ApiCreatePageRequest) CreatePageRequest(createPageRequest CreatePageRequest) ApiCreatePageRequest {
	r.createPageRequest = &createPageRequest
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiCreatePageRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiCreatePageRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiCreatePageRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.CreatePageExecute(r)
}

/*
CreatePage Create page

Creates a page in the space.

Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the corresponding space. Permission to create a page in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreatePageRequest
*/
func (a *PageApiService) CreatePage(ctx context.Context) ApiCreatePageRequest {
	return ApiCreatePageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Page
func (a *PageApiService) CreatePageExecute(r ApiCreatePageRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageApiService.CreatePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPageRequest == nil {
		return localVarReturnValue, nil, reportError("createPageRequest is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePageRequest struct {
	ctx        context.Context
	ApiService PageApi
	id         int64
}

func (r ApiDeletePageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePageExecute(r)
}

/*
DeletePage Delete page

Delete a page by id.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space. Permission to delete pages in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the page to be deleted.
	@return ApiDeletePageRequest
*/
func (a *PageApiService) DeletePage(ctx context.Context, id int64) ApiDeletePageRequest {
	return ApiDeletePageRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PageApiService) DeletePageExecute(r ApiDeletePageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageApiService.DeletePage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLabelPagesRequest struct {
	ctx                   context.Context
	ApiService            PageApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *PageSortOrder
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetLabelPagesRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetLabelPagesRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetLabelPagesRequest) Sort(sort PageSortOrder) ApiGetLabelPagesRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetLabelPagesRequest) Cursor(cursor string) ApiGetLabelPagesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetLabelPagesRequest) Limit(limit int32) ApiGetLabelPagesRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetLabelPagesRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetLabelPagesRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetLabelPagesRequest) Execute() (*MultiEntityResultPage, *http.Response, error) {
	return r.ApiService.GetLabelPagesExecute(r)
}

/*
GetLabelPages Get pages for label

Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the label for which pages should be returned.
	@return ApiGetLabelPagesRequest
*/
func (a *PageApiService) GetLabelPages(ctx context.Context, id int64) ApiGetLabelPagesRequest {
	return ApiGetLabelPagesRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultPage
func (a *PageApiService) GetLabelPagesExecute(r ApiGetLabelPagesRequest) (*MultiEntityResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageApiService.GetLabelPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/labels/{id}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageByIdRequest struct {
	ctx                   context.Context
	ApiService            PageApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	getDraft              *bool
	version               *int32
	serializeIdsAsStrings *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPageByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPageByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Retrieve the draft version of this page.
func (r ApiGetPageByIdRequest) GetDraft(getDraft bool) ApiGetPageByIdRequest {
	r.getDraft = &getDraft
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetPageByIdRequest) Version(version int32) ApiGetPageByIdRequest {
	r.version = &version
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetPageByIdRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetPageByIdRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetPageByIdRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.GetPageByIdExecute(r)
}

/*
GetPageById Get page by id

Returns a specific page.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the page to be returned. If you don't know the page ID, use Get pages and filter the results.
	@return ApiGetPageByIdRequest
*/
func (a *PageApiService) GetPageById(ctx context.Context, id int64) ApiGetPageByIdRequest {
	return ApiGetPageByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Page
func (a *PageApiService) GetPageByIdExecute(r ApiGetPageByIdRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageApiService.GetPageById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.getDraft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "get-draft", r.getDraft, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPagesRequest struct {
	ctx                   context.Context
	ApiService            PageApi
	id                    *[]int64
	status                *string
	bodyFormat            *PrimaryBodyRepresentation
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// Filter the results based on page ids. Multiple page ids can be specified as a comma-separated list.
func (r ApiGetPagesRequest) Id(id []int64) ApiGetPagesRequest {
	r.id = &id
	return r
}

// Filter the results to pages based on their status.
func (r ApiGetPagesRequest) Status(status string) ApiGetPagesRequest {
	r.status = &status
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPagesRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPagesRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPagesRequest) Cursor(cursor string) ApiGetPagesRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPagesRequest) Limit(limit int32) ApiGetPagesRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetPagesRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetPagesRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetPagesRequest) Execute() (*MultiEntityResultPage, *http.Response, error) {
	return r.ApiService.GetPagesExecute(r)
}

/*
GetPages Get pages

Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).
Only pages that the user has permission to view will be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPagesRequest
*/
func (a *PageApiService) GetPages(ctx context.Context) ApiGetPagesRequest {
	return ApiGetPagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultPage
func (a *PageApiService) GetPagesExecute(r ApiGetPagesRequest) (*MultiEntityResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageApiService.GetPages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPagesInSpaceRequest struct {
	ctx                   context.Context
	ApiService            PageApi
	id                    int64
	status                *string
	bodyFormat            *PrimaryBodyRepresentation
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// Filter the results to pages based on their status.
func (r ApiGetPagesInSpaceRequest) Status(status string) ApiGetPagesInSpaceRequest {
	r.status = &status
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPagesInSpaceRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPagesInSpaceRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPagesInSpaceRequest) Cursor(cursor string) ApiGetPagesInSpaceRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPagesInSpaceRequest) Limit(limit int32) ApiGetPagesInSpaceRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetPagesInSpaceRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetPagesInSpaceRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetPagesInSpaceRequest) Execute() (*MultiEntityResultPage, *http.Response, error) {
	return r.ApiService.GetPagesInSpaceExecute(r)
}

/*
GetPagesInSpace Get pages in space

Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
Only pages that the user has permission to view will be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the space for which pages should be returned.
	@return ApiGetPagesInSpaceRequest
*/
func (a *PageApiService) GetPagesInSpace(ctx context.Context, id int64) ApiGetPagesInSpaceRequest {
	return ApiGetPagesInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultPage
func (a *PageApiService) GetPagesInSpaceExecute(r ApiGetPagesInSpaceRequest) (*MultiEntityResultPage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageApiService.GetPagesInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/pages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePageRequest struct {
	ctx                   context.Context
	ApiService            PageApi
	id                    int64
	updatePageRequest     *UpdatePageRequest
	serializeIdsAsStrings *bool
}

func (r ApiUpdatePageRequest) UpdatePageRequest(updatePageRequest UpdatePageRequest) ApiUpdatePageRequest {
	r.updatePageRequest = &updatePageRequest
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiUpdatePageRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiUpdatePageRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiUpdatePageRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.UpdatePageExecute(r)
}

/*
UpdatePage Update page

Update a page by id.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the page and its corresponding space. Permission to update pages in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results.
	@return ApiUpdatePageRequest
*/
func (a *PageApiService) UpdatePage(ctx context.Context, id int64) ApiUpdatePageRequest {
	return ApiUpdatePageRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Page
func (a *PageApiService) UpdatePageExecute(r ApiUpdatePageRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PageApiService.UpdatePage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePageRequest == nil {
		return localVarReturnValue, nil, reportError("updatePageRequest is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
