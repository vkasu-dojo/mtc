/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confluence

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type CustomContentApi interface {

	/*
		CreateCustomContent Create custom content

		Creates a new custom content in the given space, page, blogpost or other custom content.

	Only one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is required in the request body.
	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateCustomContentRequest
	*/
	CreateCustomContent(ctx context.Context) ApiCreateCustomContentRequest

	// CreateCustomContentExecute executes the request
	//  @return CustomContent
	CreateCustomContentExecute(r ApiCreateCustomContentRequest) (*CustomContent, *http.Response, error)

	/*
		DeleteCustomContent Delete custom content

		Delete a custom content by id.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to delete custom content in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the custom content to be deleted.
		@return ApiDeleteCustomContentRequest
	*/
	DeleteCustomContent(ctx context.Context, id int64) ApiDeleteCustomContentRequest

	// DeleteCustomContentExecute executes the request
	DeleteCustomContentExecute(r ApiDeleteCustomContentRequest) (*http.Response, error)

	/*
		GetCustomContentById Get custom content by id

		Returns a specific piece of custom content.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the custom content to be returned. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.
		@return ApiGetCustomContentByIdRequest
	*/
	GetCustomContentById(ctx context.Context, id int64) ApiGetCustomContentByIdRequest

	// GetCustomContentByIdExecute executes the request
	//  @return CustomContent
	GetCustomContentByIdExecute(r ApiGetCustomContentByIdRequest) (*CustomContent, *http.Response, error)

	/*
		GetCustomContentByType Get custom content by type

		Returns all custom content for a given type. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetCustomContentByTypeRequest
	*/
	GetCustomContentByType(ctx context.Context) ApiGetCustomContentByTypeRequest

	// GetCustomContentByTypeExecute executes the request
	//  @return MultiEntityResultCustomContent
	GetCustomContentByTypeExecute(r ApiGetCustomContentByTypeRequest) (*MultiEntityResultCustomContent, *http.Response, error)

	/*
		GetCustomContentByTypeInBlogPost Get custom content by type in blog post

		Returns all custom content for a given type within a given blogpost. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the blog post for which custom content should be returned.
		@return ApiGetCustomContentByTypeInBlogPostRequest
	*/
	GetCustomContentByTypeInBlogPost(ctx context.Context, id int64) ApiGetCustomContentByTypeInBlogPostRequest

	// GetCustomContentByTypeInBlogPostExecute executes the request
	//  @return MultiEntityResultCustomContent
	GetCustomContentByTypeInBlogPostExecute(r ApiGetCustomContentByTypeInBlogPostRequest) (*MultiEntityResultCustomContent, *http.Response, error)

	/*
		GetCustomContentByTypeInPage Get custom content by type in page

		Returns all custom content for a given type within a given page. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the custom content, the container of the custom content (page), and the corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the page for which custom content should be returned.
		@return ApiGetCustomContentByTypeInPageRequest
	*/
	GetCustomContentByTypeInPage(ctx context.Context, id int64) ApiGetCustomContentByTypeInPageRequest

	// GetCustomContentByTypeInPageExecute executes the request
	//  @return MultiEntityResultCustomContent
	GetCustomContentByTypeInPageExecute(r ApiGetCustomContentByTypeInPageRequest) (*MultiEntityResultCustomContent, *http.Response, error)

	/*
		GetCustomContentByTypeInSpace Get custom content by type in space

		Returns all custom content for a given type within a given space. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the custom content and the corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the space for which custom content should be returned.
		@return ApiGetCustomContentByTypeInSpaceRequest
	*/
	GetCustomContentByTypeInSpace(ctx context.Context, id int64) ApiGetCustomContentByTypeInSpaceRequest

	// GetCustomContentByTypeInSpaceExecute executes the request
	//  @return MultiEntityResultCustomContent
	GetCustomContentByTypeInSpaceExecute(r ApiGetCustomContentByTypeInSpaceRequest) (*MultiEntityResultCustomContent, *http.Response, error)

	/*
		UpdateCustomContent Update custom content

		Update a custom content by id.

	`spaceId` is always required and maximum one of `pageId`, `blogPostId`, or `customContentId` is allowed in the request body.
	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the custom content to be updated. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.
		@return ApiUpdateCustomContentRequest
	*/
	UpdateCustomContent(ctx context.Context, id int64) ApiUpdateCustomContentRequest

	// UpdateCustomContentExecute executes the request
	//  @return CustomContent
	UpdateCustomContentExecute(r ApiUpdateCustomContentRequest) (*CustomContent, *http.Response, error)
}

// CustomContentApiService CustomContentApi service
type CustomContentApiService service

type ApiCreateCustomContentRequest struct {
	ctx                        context.Context
	ApiService                 CustomContentApi
	createCustomContentRequest *CreateCustomContentRequest
	serializeIdsAsStrings      *bool
}

func (r ApiCreateCustomContentRequest) CreateCustomContentRequest(createCustomContentRequest CreateCustomContentRequest) ApiCreateCustomContentRequest {
	r.createCustomContentRequest = &createCustomContentRequest
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiCreateCustomContentRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiCreateCustomContentRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiCreateCustomContentRequest) Execute() (*CustomContent, *http.Response, error) {
	return r.ApiService.CreateCustomContentExecute(r)
}

/*
CreateCustomContent Create custom content

Creates a new custom content in the given space, page, blogpost or other custom content.

Only one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is required in the request body.
**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateCustomContentRequest
*/
func (a *CustomContentApiService) CreateCustomContent(ctx context.Context) ApiCreateCustomContentRequest {
	return ApiCreateCustomContentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CustomContent
func (a *CustomContentApiService) CreateCustomContentExecute(r ApiCreateCustomContentRequest) (*CustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.CreateCustomContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCustomContentRequest == nil {
		return localVarReturnValue, nil, reportError("createCustomContentRequest is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCustomContentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCustomContentRequest struct {
	ctx        context.Context
	ApiService CustomContentApi
	id         int64
}

func (r ApiDeleteCustomContentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomContentExecute(r)
}

/*
DeleteCustomContent Delete custom content

Delete a custom content by id.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to delete custom content in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the custom content to be deleted.
	@return ApiDeleteCustomContentRequest
*/
func (a *CustomContentApiService) DeleteCustomContent(ctx context.Context, id int64) ApiDeleteCustomContentRequest {
	return ApiDeleteCustomContentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CustomContentApiService) DeleteCustomContentExecute(r ApiDeleteCustomContentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.DeleteCustomContent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCustomContentByIdRequest struct {
	ctx                   context.Context
	ApiService            CustomContentApi
	id                    int64
	bodyFormat            *CustomContentBodyRepresentation
	version               *int32
	serializeIdsAsStrings *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByIdRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetCustomContentByIdRequest) Version(version int32) ApiGetCustomContentByIdRequest {
	r.version = &version
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetCustomContentByIdRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetCustomContentByIdRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetCustomContentByIdRequest) Execute() (*CustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByIdExecute(r)
}

/*
GetCustomContentById Get custom content by id

Returns a specific piece of custom content.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the custom content to be returned. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.
	@return ApiGetCustomContentByIdRequest
*/
func (a *CustomContentApiService) GetCustomContentById(ctx context.Context, id int64) ApiGetCustomContentByIdRequest {
	return ApiGetCustomContentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CustomContent
func (a *CustomContentApiService) GetCustomContentByIdExecute(r ApiGetCustomContentByIdRequest) (*CustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.GetCustomContentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeRequest struct {
	ctx                   context.Context
	ApiService            CustomContentApi
	type_                 *string
	id                    *[]int64
	cursor                *string
	limit                 *int32
	bodyFormat            *CustomContentBodyRepresentation
	serializeIdsAsStrings *bool
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeRequest) Type_(type_ string) ApiGetCustomContentByTypeRequest {
	r.type_ = &type_
	return r
}

// Filter the results based on custom content ids. Multiple custom content ids can be specified as a comma-separated list.
func (r ApiGetCustomContentByTypeRequest) Id(id []int64) ApiGetCustomContentByTypeRequest {
	r.id = &id
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeRequest) Cursor(cursor string) ApiGetCustomContentByTypeRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeRequest) Limit(limit int32) ApiGetCustomContentByTypeRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetCustomContentByTypeRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetCustomContentByTypeRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetCustomContentByTypeRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeExecute(r)
}

/*
GetCustomContentByType Get custom content by type

Returns all custom content for a given type. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetCustomContentByTypeRequest
*/
func (a *CustomContentApiService) GetCustomContentByType(ctx context.Context) ApiGetCustomContentByTypeRequest {
	return ApiGetCustomContentByTypeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultCustomContent
func (a *CustomContentApiService) GetCustomContentByTypeExecute(r ApiGetCustomContentByTypeRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.GetCustomContentByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeInBlogPostRequest struct {
	ctx                   context.Context
	ApiService            CustomContentApi
	id                    int64
	type_                 *string
	cursor                *string
	limit                 *int32
	bodyFormat            *CustomContentBodyRepresentation
	serializeIdsAsStrings *bool
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeInBlogPostRequest) Type_(type_ string) ApiGetCustomContentByTypeInBlogPostRequest {
	r.type_ = &type_
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeInBlogPostRequest) Cursor(cursor string) ApiGetCustomContentByTypeInBlogPostRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeInBlogPostRequest) Limit(limit int32) ApiGetCustomContentByTypeInBlogPostRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeInBlogPostRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeInBlogPostRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetCustomContentByTypeInBlogPostRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetCustomContentByTypeInBlogPostRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetCustomContentByTypeInBlogPostRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeInBlogPostExecute(r)
}

/*
GetCustomContentByTypeInBlogPost Get custom content by type in blog post

Returns all custom content for a given type within a given blogpost. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the blog post for which custom content should be returned.
	@return ApiGetCustomContentByTypeInBlogPostRequest
*/
func (a *CustomContentApiService) GetCustomContentByTypeInBlogPost(ctx context.Context, id int64) ApiGetCustomContentByTypeInBlogPostRequest {
	return ApiGetCustomContentByTypeInBlogPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultCustomContent
func (a *CustomContentApiService) GetCustomContentByTypeInBlogPostExecute(r ApiGetCustomContentByTypeInBlogPostRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.GetCustomContentByTypeInBlogPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/custom-content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeInPageRequest struct {
	ctx                   context.Context
	ApiService            CustomContentApi
	id                    int64
	type_                 *string
	cursor                *string
	limit                 *int32
	bodyFormat            *CustomContentBodyRepresentation
	serializeIdsAsStrings *bool
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeInPageRequest) Type_(type_ string) ApiGetCustomContentByTypeInPageRequest {
	r.type_ = &type_
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeInPageRequest) Cursor(cursor string) ApiGetCustomContentByTypeInPageRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeInPageRequest) Limit(limit int32) ApiGetCustomContentByTypeInPageRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeInPageRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeInPageRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetCustomContentByTypeInPageRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetCustomContentByTypeInPageRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetCustomContentByTypeInPageRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeInPageExecute(r)
}

/*
GetCustomContentByTypeInPage Get custom content by type in page

Returns all custom content for a given type within a given page. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content, the container of the custom content (page), and the corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the page for which custom content should be returned.
	@return ApiGetCustomContentByTypeInPageRequest
*/
func (a *CustomContentApiService) GetCustomContentByTypeInPage(ctx context.Context, id int64) ApiGetCustomContentByTypeInPageRequest {
	return ApiGetCustomContentByTypeInPageRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultCustomContent
func (a *CustomContentApiService) GetCustomContentByTypeInPageExecute(r ApiGetCustomContentByTypeInPageRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.GetCustomContentByTypeInPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/custom-content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCustomContentByTypeInSpaceRequest struct {
	ctx                   context.Context
	ApiService            CustomContentApi
	id                    int64
	type_                 *string
	cursor                *string
	limit                 *int32
	bodyFormat            *CustomContentBodyRepresentation
	serializeIdsAsStrings *bool
}

// The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
func (r ApiGetCustomContentByTypeInSpaceRequest) Type_(type_ string) ApiGetCustomContentByTypeInSpaceRequest {
	r.type_ = &type_
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetCustomContentByTypeInSpaceRequest) Cursor(cursor string) ApiGetCustomContentByTypeInSpaceRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetCustomContentByTypeInSpaceRequest) Limit(limit int32) ApiGetCustomContentByTypeInSpaceRequest {
	r.limit = &limit
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
func (r ApiGetCustomContentByTypeInSpaceRequest) BodyFormat(bodyFormat CustomContentBodyRepresentation) ApiGetCustomContentByTypeInSpaceRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetCustomContentByTypeInSpaceRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetCustomContentByTypeInSpaceRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetCustomContentByTypeInSpaceRequest) Execute() (*MultiEntityResultCustomContent, *http.Response, error) {
	return r.ApiService.GetCustomContentByTypeInSpaceExecute(r)
}

/*
GetCustomContentByTypeInSpace Get custom content by type in space

Returns all custom content for a given type within a given space. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the custom content and the corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the space for which custom content should be returned.
	@return ApiGetCustomContentByTypeInSpaceRequest
*/
func (a *CustomContentApiService) GetCustomContentByTypeInSpace(ctx context.Context, id int64) ApiGetCustomContentByTypeInSpaceRequest {
	return ApiGetCustomContentByTypeInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultCustomContent
func (a *CustomContentApiService) GetCustomContentByTypeInSpaceExecute(r ApiGetCustomContentByTypeInSpaceRequest) (*MultiEntityResultCustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultCustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.GetCustomContentByTypeInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/custom-content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCustomContentRequest struct {
	ctx                        context.Context
	ApiService                 CustomContentApi
	id                         int64
	updateCustomContentRequest *UpdateCustomContentRequest
	serializeIdsAsStrings      *bool
}

func (r ApiUpdateCustomContentRequest) UpdateCustomContentRequest(updateCustomContentRequest UpdateCustomContentRequest) ApiUpdateCustomContentRequest {
	r.updateCustomContentRequest = &updateCustomContentRequest
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiUpdateCustomContentRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiUpdateCustomContentRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiUpdateCustomContentRequest) Execute() (*CustomContent, *http.Response, error) {
	return r.ApiService.UpdateCustomContentExecute(r)
}

/*
UpdateCustomContent Update custom content

Update a custom content by id.

`spaceId` is always required and maximum one of `pageId`, `blogPostId`, or `customContentId` is allowed in the request body.
**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the custom content to be updated. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.
	@return ApiUpdateCustomContentRequest
*/
func (a *CustomContentApiService) UpdateCustomContent(ctx context.Context, id int64) ApiUpdateCustomContentRequest {
	return ApiUpdateCustomContentRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return CustomContent
func (a *CustomContentApiService) UpdateCustomContentExecute(r ApiUpdateCustomContentRequest) (*CustomContent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CustomContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomContentApiService.UpdateCustomContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/custom-content/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCustomContentRequest == nil {
		return localVarReturnValue, nil, reportError("updateCustomContentRequest is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCustomContentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
