/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confluence

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type CommentApi interface {

	/*
		CreateFooterComment Create footer comment

		Create a footer comment. This can be at the top level (specifying pageId or blogPostId in the request body)
	or as a reply (specifying parentCommentId in the request body).

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateFooterCommentRequest
	*/
	CreateFooterComment(ctx context.Context) ApiCreateFooterCommentRequest

	// CreateFooterCommentExecute executes the request
	//  @return FooterCommentModel
	CreateFooterCommentExecute(r ApiCreateFooterCommentRequest) (*FooterCommentModel, *http.Response, error)

	/*
		CreateInlineComment Create inline comment

		Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body)
	or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the
	request body is used to select the text the inline comment should be tied to. This is what determines the text
	highlighting when viewing a page in Confluence.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateInlineCommentRequest
	*/
	CreateInlineComment(ctx context.Context) ApiCreateInlineCommentRequest

	// CreateInlineCommentExecute executes the request
	//  @return InlineCommentModel
	CreateInlineCommentExecute(r ApiCreateInlineCommentRequest) (*InlineCommentModel, *http.Response, error)

	/*
		DeleteFooterComment Delete footer comment

		Deletes a footer comment. This is a permanent deletion and cannot be reverted.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param commentId The ID of the comment to be retrieved.
		@return ApiDeleteFooterCommentRequest
	*/
	DeleteFooterComment(ctx context.Context, commentId int64) ApiDeleteFooterCommentRequest

	// DeleteFooterCommentExecute executes the request
	DeleteFooterCommentExecute(r ApiDeleteFooterCommentRequest) (*http.Response, error)

	/*
		DeleteInlineComment Delete inline comment

		Deletes an inline comment. This is a permanent deletion and cannot be reverted.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param commentId The ID of the comment to be deleted.
		@return ApiDeleteInlineCommentRequest
	*/
	DeleteInlineComment(ctx context.Context, commentId int64) ApiDeleteInlineCommentRequest

	// DeleteInlineCommentExecute executes the request
	DeleteInlineCommentExecute(r ApiDeleteInlineCommentRequest) (*http.Response, error)

	/*
		GetBlogPostFooterComments Get footer comments for blog post

		Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the blog post and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the blog post for which footer comments should be returned.
		@return ApiGetBlogPostFooterCommentsRequest
	*/
	GetBlogPostFooterComments(ctx context.Context, id int64) ApiGetBlogPostFooterCommentsRequest

	// GetBlogPostFooterCommentsExecute executes the request
	//  @return MultiEntityResultBlogPostCommentModel
	GetBlogPostFooterCommentsExecute(r ApiGetBlogPostFooterCommentsRequest) (*MultiEntityResultBlogPostCommentModel, *http.Response, error)

	/*
		GetBlogPostInlineComments Get inline comments for blog post

		Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the blog post and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the blog post for which inline comments should be returned.
		@return ApiGetBlogPostInlineCommentsRequest
	*/
	GetBlogPostInlineComments(ctx context.Context, id int64) ApiGetBlogPostInlineCommentsRequest

	// GetBlogPostInlineCommentsExecute executes the request
	//  @return MultiEntityResultBlogPostInlineCommentModel
	GetBlogPostInlineCommentsExecute(r ApiGetBlogPostInlineCommentsRequest) (*MultiEntityResultBlogPostInlineCommentModel, *http.Response, error)

	/*
		GetFooterCommentById Get footer comment by id

		Retrieves a footer comment by id

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param commentId The ID of the comment to be retrieved.
		@return ApiGetFooterCommentByIdRequest
	*/
	GetFooterCommentById(ctx context.Context, commentId int64) ApiGetFooterCommentByIdRequest

	// GetFooterCommentByIdExecute executes the request
	//  @return FooterCommentModel
	GetFooterCommentByIdExecute(r ApiGetFooterCommentByIdRequest) (*FooterCommentModel, *http.Response, error)

	/*
		GetFooterCommentChildren Get children footer comments

		Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the parent comment for which footer comment children should be returned.
		@return ApiGetFooterCommentChildrenRequest
	*/
	GetFooterCommentChildren(ctx context.Context, id int64) ApiGetFooterCommentChildrenRequest

	// GetFooterCommentChildrenExecute executes the request
	//  @return MultiEntityResultChildrenCommentModel
	GetFooterCommentChildrenExecute(r ApiGetFooterCommentChildrenRequest) (*MultiEntityResultChildrenCommentModel, *http.Response, error)

	/*
		GetInlineCommentById Get inline comment by id

		Retrieves an inline comment by id

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param commentId The ID of the comment to be retrieved.
		@return ApiGetInlineCommentByIdRequest
	*/
	GetInlineCommentById(ctx context.Context, commentId int64) ApiGetInlineCommentByIdRequest

	// GetInlineCommentByIdExecute executes the request
	//  @return InlineCommentModel
	GetInlineCommentByIdExecute(r ApiGetInlineCommentByIdRequest) (*InlineCommentModel, *http.Response, error)

	/*
		GetInlineCommentChildren Get children inline comments

		Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the parent comment for which inline comment children should be returned.
		@return ApiGetInlineCommentChildrenRequest
	*/
	GetInlineCommentChildren(ctx context.Context, id int64) ApiGetInlineCommentChildrenRequest

	// GetInlineCommentChildrenExecute executes the request
	//  @return MultiEntityResultInlineCommentChildrenModel
	GetInlineCommentChildrenExecute(r ApiGetInlineCommentChildrenRequest) (*MultiEntityResultInlineCommentChildrenModel, *http.Response, error)

	/*
		GetPageFooterComments Get footer comments for page

		Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the page for which footer comments should be returned.
		@return ApiGetPageFooterCommentsRequest
	*/
	GetPageFooterComments(ctx context.Context, id int64) ApiGetPageFooterCommentsRequest

	// GetPageFooterCommentsExecute executes the request
	//  @return MultiEntityResultPageCommentModel
	GetPageFooterCommentsExecute(r ApiGetPageFooterCommentsRequest) (*MultiEntityResultPageCommentModel, *http.Response, error)

	/*
		GetPageInlineComments Get inline comments for page

		Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the page for which inline comments should be returned.
		@return ApiGetPageInlineCommentsRequest
	*/
	GetPageInlineComments(ctx context.Context, id int64) ApiGetPageInlineCommentsRequest

	// GetPageInlineCommentsExecute executes the request
	//  @return MultiEntityResultPageInlineCommentModel
	GetPageInlineCommentsExecute(r ApiGetPageInlineCommentsRequest) (*MultiEntityResultPageInlineCommentModel, *http.Response, error)

	/*
		UpdateFooterComment Update footer comment

		Update a footer comment. This can be used to update the body text of a comment.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param commentId The ID of the comment to be retrieved.
		@return ApiUpdateFooterCommentRequest
	*/
	UpdateFooterComment(ctx context.Context, commentId int64) ApiUpdateFooterCommentRequest

	// UpdateFooterCommentExecute executes the request
	//  @return FooterCommentModel
	UpdateFooterCommentExecute(r ApiUpdateFooterCommentRequest) (*FooterCommentModel, *http.Response, error)

	/*
		UpdateInlineComment Update inline comment

		Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param commentId The ID of the comment to be retrieved.
		@return ApiUpdateInlineCommentRequest
	*/
	UpdateInlineComment(ctx context.Context, commentId int64) ApiUpdateInlineCommentRequest

	// UpdateInlineCommentExecute executes the request
	//  @return InlineCommentModel
	UpdateInlineCommentExecute(r ApiUpdateInlineCommentRequest) (*InlineCommentModel, *http.Response, error)
}

// CommentApiService CommentApi service
type CommentApiService service

type ApiCreateFooterCommentRequest struct {
	ctx                      context.Context
	ApiService               CommentApi
	createFooterCommentModel *CreateFooterCommentModel
	serializeIdsAsStrings    *bool
}

// The footer comment to be created
func (r ApiCreateFooterCommentRequest) CreateFooterCommentModel(createFooterCommentModel CreateFooterCommentModel) ApiCreateFooterCommentRequest {
	r.createFooterCommentModel = &createFooterCommentModel
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiCreateFooterCommentRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiCreateFooterCommentRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiCreateFooterCommentRequest) Execute() (*FooterCommentModel, *http.Response, error) {
	return r.ApiService.CreateFooterCommentExecute(r)
}

/*
CreateFooterComment Create footer comment

Create a footer comment. This can be at the top level (specifying pageId or blogPostId in the request body)
or as a reply (specifying parentCommentId in the request body).

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateFooterCommentRequest
*/
func (a *CommentApiService) CreateFooterComment(ctx context.Context) ApiCreateFooterCommentRequest {
	return ApiCreateFooterCommentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FooterCommentModel
func (a *CommentApiService) CreateFooterCommentExecute(r ApiCreateFooterCommentRequest) (*FooterCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FooterCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.CreateFooterComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFooterCommentModel == nil {
		return localVarReturnValue, nil, reportError("createFooterCommentModel is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFooterCommentModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInlineCommentRequest struct {
	ctx                      context.Context
	ApiService               CommentApi
	createInlineCommentModel *CreateInlineCommentModel
	serializeIdsAsStrings    *bool
}

// The inline comment to be created
func (r ApiCreateInlineCommentRequest) CreateInlineCommentModel(createInlineCommentModel CreateInlineCommentModel) ApiCreateInlineCommentRequest {
	r.createInlineCommentModel = &createInlineCommentModel
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiCreateInlineCommentRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiCreateInlineCommentRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiCreateInlineCommentRequest) Execute() (*InlineCommentModel, *http.Response, error) {
	return r.ApiService.CreateInlineCommentExecute(r)
}

/*
CreateInlineComment Create inline comment

Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body)
or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the
request body is used to select the text the inline comment should be tied to. This is what determines the text
highlighting when viewing a page in Confluence.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateInlineCommentRequest
*/
func (a *CommentApiService) CreateInlineComment(ctx context.Context) ApiCreateInlineCommentRequest {
	return ApiCreateInlineCommentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return InlineCommentModel
func (a *CommentApiService) CreateInlineCommentExecute(r ApiCreateInlineCommentRequest) (*InlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.CreateInlineComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createInlineCommentModel == nil {
		return localVarReturnValue, nil, reportError("createInlineCommentModel is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createInlineCommentModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFooterCommentRequest struct {
	ctx        context.Context
	ApiService CommentApi
	commentId  int64
}

func (r ApiDeleteFooterCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFooterCommentExecute(r)
}

/*
DeleteFooterComment Delete footer comment

Deletes a footer comment. This is a permanent deletion and cannot be reverted.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param commentId The ID of the comment to be retrieved.
	@return ApiDeleteFooterCommentRequest
*/
func (a *CommentApiService) DeleteFooterComment(ctx context.Context, commentId int64) ApiDeleteFooterCommentRequest {
	return ApiDeleteFooterCommentRequest{
		ApiService: a,
		ctx:        ctx,
		commentId:  commentId,
	}
}

// Execute executes the request
func (a *CommentApiService) DeleteFooterCommentExecute(r ApiDeleteFooterCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.DeleteFooterComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteInlineCommentRequest struct {
	ctx        context.Context
	ApiService CommentApi
	commentId  int64
}

func (r ApiDeleteInlineCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteInlineCommentExecute(r)
}

/*
DeleteInlineComment Delete inline comment

Deletes an inline comment. This is a permanent deletion and cannot be reverted.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param commentId The ID of the comment to be deleted.
	@return ApiDeleteInlineCommentRequest
*/
func (a *CommentApiService) DeleteInlineComment(ctx context.Context, commentId int64) ApiDeleteInlineCommentRequest {
	return ApiDeleteInlineCommentRequest{
		ApiService: a,
		ctx:        ctx,
		commentId:  commentId,
	}
}

// Execute executes the request
func (a *CommentApiService) DeleteInlineCommentExecute(r ApiDeleteInlineCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.DeleteInlineComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBlogPostFooterCommentsRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *CommentSortOrder
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostFooterCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostFooterCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostFooterCommentsRequest) Sort(sort CommentSortOrder) ApiGetBlogPostFooterCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostFooterCommentsRequest) Cursor(cursor string) ApiGetBlogPostFooterCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostFooterCommentsRequest) Limit(limit int32) ApiGetBlogPostFooterCommentsRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetBlogPostFooterCommentsRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetBlogPostFooterCommentsRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetBlogPostFooterCommentsRequest) Execute() (*MultiEntityResultBlogPostCommentModel, *http.Response, error) {
	return r.ApiService.GetBlogPostFooterCommentsExecute(r)
}

/*
GetBlogPostFooterComments Get footer comments for blog post

Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the blog post and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the blog post for which footer comments should be returned.
	@return ApiGetBlogPostFooterCommentsRequest
*/
func (a *CommentApiService) GetBlogPostFooterComments(ctx context.Context, id int64) ApiGetBlogPostFooterCommentsRequest {
	return ApiGetBlogPostFooterCommentsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultBlogPostCommentModel
func (a *CommentApiService) GetBlogPostFooterCommentsExecute(r ApiGetBlogPostFooterCommentsRequest) (*MultiEntityResultBlogPostCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultBlogPostCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetBlogPostFooterComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/footer-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostInlineCommentsRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *CommentSortOrder
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostInlineCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostInlineCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetBlogPostInlineCommentsRequest) Sort(sort CommentSortOrder) ApiGetBlogPostInlineCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostInlineCommentsRequest) Cursor(cursor string) ApiGetBlogPostInlineCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of inline comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostInlineCommentsRequest) Limit(limit int32) ApiGetBlogPostInlineCommentsRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetBlogPostInlineCommentsRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetBlogPostInlineCommentsRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetBlogPostInlineCommentsRequest) Execute() (*MultiEntityResultBlogPostInlineCommentModel, *http.Response, error) {
	return r.ApiService.GetBlogPostInlineCommentsExecute(r)
}

/*
GetBlogPostInlineComments Get inline comments for blog post

Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the blog post and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the blog post for which inline comments should be returned.
	@return ApiGetBlogPostInlineCommentsRequest
*/
func (a *CommentApiService) GetBlogPostInlineComments(ctx context.Context, id int64) ApiGetBlogPostInlineCommentsRequest {
	return ApiGetBlogPostInlineCommentsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultBlogPostInlineCommentModel
func (a *CommentApiService) GetBlogPostInlineCommentsExecute(r ApiGetBlogPostInlineCommentsRequest) (*MultiEntityResultBlogPostInlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultBlogPostInlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetBlogPostInlineComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}/inline-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFooterCommentByIdRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	commentId             int64
	bodyFormat            *PrimaryBodyRepresentation
	version               *int32
	serializeIdsAsStrings *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetFooterCommentByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetFooterCommentByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetFooterCommentByIdRequest) Version(version int32) ApiGetFooterCommentByIdRequest {
	r.version = &version
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetFooterCommentByIdRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetFooterCommentByIdRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetFooterCommentByIdRequest) Execute() (*FooterCommentModel, *http.Response, error) {
	return r.ApiService.GetFooterCommentByIdExecute(r)
}

/*
GetFooterCommentById Get footer comment by id

# Retrieves a footer comment by id

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param commentId The ID of the comment to be retrieved.
	@return ApiGetFooterCommentByIdRequest
*/
func (a *CommentApiService) GetFooterCommentById(ctx context.Context, commentId int64) ApiGetFooterCommentByIdRequest {
	return ApiGetFooterCommentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return FooterCommentModel
func (a *CommentApiService) GetFooterCommentByIdExecute(r ApiGetFooterCommentByIdRequest) (*FooterCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FooterCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetFooterCommentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFooterCommentChildrenRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *CommentSortOrder
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetFooterCommentChildrenRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetFooterCommentChildrenRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetFooterCommentChildrenRequest) Sort(sort CommentSortOrder) ApiGetFooterCommentChildrenRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetFooterCommentChildrenRequest) Cursor(cursor string) ApiGetFooterCommentChildrenRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetFooterCommentChildrenRequest) Limit(limit int32) ApiGetFooterCommentChildrenRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetFooterCommentChildrenRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetFooterCommentChildrenRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetFooterCommentChildrenRequest) Execute() (*MultiEntityResultChildrenCommentModel, *http.Response, error) {
	return r.ApiService.GetFooterCommentChildrenExecute(r)
}

/*
GetFooterCommentChildren Get children footer comments

Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the parent comment for which footer comment children should be returned.
	@return ApiGetFooterCommentChildrenRequest
*/
func (a *CommentApiService) GetFooterCommentChildren(ctx context.Context, id int64) ApiGetFooterCommentChildrenRequest {
	return ApiGetFooterCommentChildrenRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultChildrenCommentModel
func (a *CommentApiService) GetFooterCommentChildrenExecute(r ApiGetFooterCommentChildrenRequest) (*MultiEntityResultChildrenCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultChildrenCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetFooterCommentChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInlineCommentByIdRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	commentId             int64
	bodyFormat            *PrimaryBodyRepresentation
	version               *int32
	serializeIdsAsStrings *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetInlineCommentByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetInlineCommentByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetInlineCommentByIdRequest) Version(version int32) ApiGetInlineCommentByIdRequest {
	r.version = &version
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetInlineCommentByIdRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetInlineCommentByIdRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetInlineCommentByIdRequest) Execute() (*InlineCommentModel, *http.Response, error) {
	return r.ApiService.GetInlineCommentByIdExecute(r)
}

/*
GetInlineCommentById Get inline comment by id

# Retrieves an inline comment by id

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param commentId The ID of the comment to be retrieved.
	@return ApiGetInlineCommentByIdRequest
*/
func (a *CommentApiService) GetInlineCommentById(ctx context.Context, commentId int64) ApiGetInlineCommentByIdRequest {
	return ApiGetInlineCommentByIdRequest{
		ApiService: a,
		ctx:        ctx,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return InlineCommentModel
func (a *CommentApiService) GetInlineCommentByIdExecute(r ApiGetInlineCommentByIdRequest) (*InlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetInlineCommentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInlineCommentChildrenRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	id                    int64
	serializeIdsAsStrings *bool
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *CommentSortOrder
	cursor                *string
	limit                 *int32
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetInlineCommentChildrenRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetInlineCommentChildrenRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetInlineCommentChildrenRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetInlineCommentChildrenRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetInlineCommentChildrenRequest) Sort(sort CommentSortOrder) ApiGetInlineCommentChildrenRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetInlineCommentChildrenRequest) Cursor(cursor string) ApiGetInlineCommentChildrenRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetInlineCommentChildrenRequest) Limit(limit int32) ApiGetInlineCommentChildrenRequest {
	r.limit = &limit
	return r
}

func (r ApiGetInlineCommentChildrenRequest) Execute() (*MultiEntityResultInlineCommentChildrenModel, *http.Response, error) {
	return r.ApiService.GetInlineCommentChildrenExecute(r)
}

/*
GetInlineCommentChildren Get children inline comments

Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the parent comment for which inline comment children should be returned.
	@return ApiGetInlineCommentChildrenRequest
*/
func (a *CommentApiService) GetInlineCommentChildren(ctx context.Context, id int64) ApiGetInlineCommentChildrenRequest {
	return ApiGetInlineCommentChildrenRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultInlineCommentChildrenModel
func (a *CommentApiService) GetInlineCommentChildrenExecute(r ApiGetInlineCommentChildrenRequest) (*MultiEntityResultInlineCommentChildrenModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultInlineCommentChildrenModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetInlineCommentChildren")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageFooterCommentsRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *CommentSortOrder
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPageFooterCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPageFooterCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPageFooterCommentsRequest) Sort(sort CommentSortOrder) ApiGetPageFooterCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPageFooterCommentsRequest) Cursor(cursor string) ApiGetPageFooterCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPageFooterCommentsRequest) Limit(limit int32) ApiGetPageFooterCommentsRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetPageFooterCommentsRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetPageFooterCommentsRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetPageFooterCommentsRequest) Execute() (*MultiEntityResultPageCommentModel, *http.Response, error) {
	return r.ApiService.GetPageFooterCommentsExecute(r)
}

/*
GetPageFooterComments Get footer comments for page

Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the page for which footer comments should be returned.
	@return ApiGetPageFooterCommentsRequest
*/
func (a *CommentApiService) GetPageFooterComments(ctx context.Context, id int64) ApiGetPageFooterCommentsRequest {
	return ApiGetPageFooterCommentsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultPageCommentModel
func (a *CommentApiService) GetPageFooterCommentsExecute(r ApiGetPageFooterCommentsRequest) (*MultiEntityResultPageCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultPageCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetPageFooterComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/footer-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPageInlineCommentsRequest struct {
	ctx                   context.Context
	ApiService            CommentApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *CommentSortOrder
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetPageInlineCommentsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetPageInlineCommentsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetPageInlineCommentsRequest) Sort(sort CommentSortOrder) ApiGetPageInlineCommentsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetPageInlineCommentsRequest) Cursor(cursor string) ApiGetPageInlineCommentsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of inline comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetPageInlineCommentsRequest) Limit(limit int32) ApiGetPageInlineCommentsRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetPageInlineCommentsRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetPageInlineCommentsRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetPageInlineCommentsRequest) Execute() (*MultiEntityResultPageInlineCommentModel, *http.Response, error) {
	return r.ApiService.GetPageInlineCommentsExecute(r)
}

/*
GetPageInlineComments Get inline comments for page

Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the page for which inline comments should be returned.
	@return ApiGetPageInlineCommentsRequest
*/
func (a *CommentApiService) GetPageInlineComments(ctx context.Context, id int64) ApiGetPageInlineCommentsRequest {
	return ApiGetPageInlineCommentsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultPageInlineCommentModel
func (a *CommentApiService) GetPageInlineCommentsExecute(r ApiGetPageInlineCommentsRequest) (*MultiEntityResultPageInlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultPageInlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.GetPageInlineComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pages/{id}/inline-comments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFooterCommentRequest struct {
	ctx                      context.Context
	ApiService               CommentApi
	commentId                int64
	updateFooterCommentModel *UpdateFooterCommentModel
	serializeIdsAsStrings    *bool
}

// The footer comment to be created
func (r ApiUpdateFooterCommentRequest) UpdateFooterCommentModel(updateFooterCommentModel UpdateFooterCommentModel) ApiUpdateFooterCommentRequest {
	r.updateFooterCommentModel = &updateFooterCommentModel
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiUpdateFooterCommentRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiUpdateFooterCommentRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiUpdateFooterCommentRequest) Execute() (*FooterCommentModel, *http.Response, error) {
	return r.ApiService.UpdateFooterCommentExecute(r)
}

/*
UpdateFooterComment Update footer comment

Update a footer comment. This can be used to update the body text of a comment.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param commentId The ID of the comment to be retrieved.
	@return ApiUpdateFooterCommentRequest
*/
func (a *CommentApiService) UpdateFooterComment(ctx context.Context, commentId int64) ApiUpdateFooterCommentRequest {
	return ApiUpdateFooterCommentRequest{
		ApiService: a,
		ctx:        ctx,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return FooterCommentModel
func (a *CommentApiService) UpdateFooterCommentExecute(r ApiUpdateFooterCommentRequest) (*FooterCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FooterCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.UpdateFooterComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/footer-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFooterCommentModel == nil {
		return localVarReturnValue, nil, reportError("updateFooterCommentModel is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFooterCommentModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateInlineCommentRequest struct {
	ctx                      context.Context
	ApiService               CommentApi
	commentId                int64
	updateInlineCommentModel *UpdateInlineCommentModel
	serializeIdsAsStrings    *bool
}

// The inline comment to be updated
func (r ApiUpdateInlineCommentRequest) UpdateInlineCommentModel(updateInlineCommentModel UpdateInlineCommentModel) ApiUpdateInlineCommentRequest {
	r.updateInlineCommentModel = &updateInlineCommentModel
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiUpdateInlineCommentRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiUpdateInlineCommentRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiUpdateInlineCommentRequest) Execute() (*InlineCommentModel, *http.Response, error) {
	return r.ApiService.UpdateInlineCommentExecute(r)
}

/*
UpdateInlineComment Update inline comment

Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param commentId The ID of the comment to be retrieved.
	@return ApiUpdateInlineCommentRequest
*/
func (a *CommentApiService) UpdateInlineComment(ctx context.Context, commentId int64) ApiUpdateInlineCommentRequest {
	return ApiUpdateInlineCommentRequest{
		ApiService: a,
		ctx:        ctx,
		commentId:  commentId,
	}
}

// Execute executes the request
//
//	@return InlineCommentModel
func (a *CommentApiService) UpdateInlineCommentExecute(r ApiUpdateInlineCommentRequest) (*InlineCommentModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InlineCommentModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CommentApiService.UpdateInlineComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inline-comments/{comment-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"comment-id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateInlineCommentModel == nil {
		return localVarReturnValue, nil, reportError("updateInlineCommentModel is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInlineCommentModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
