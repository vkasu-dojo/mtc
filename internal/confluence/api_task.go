/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confluence

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type TaskApi interface {

	/*
		GetTaskById Get task by id

		Returns a specific task.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the containing page or blog post and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the task to be returned. If you don't know the task ID, use Get tasks and filter the results.
		@return ApiGetTaskByIdRequest
	*/
	GetTaskById(ctx context.Context, id int64) ApiGetTaskByIdRequest

	// GetTaskByIdExecute executes the request
	//  @return Task
	GetTaskByIdExecute(r ApiGetTaskByIdRequest) (*Task, *http.Response, error)

	/*
		GetTasks Get tasks

		Returns all tasks. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to access the Confluence site ('Can use' global permission).
	Only tasks that the user has permission to view will be returned.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetTasksRequest
	*/
	GetTasks(ctx context.Context) ApiGetTasksRequest

	// GetTasksExecute executes the request
	//  @return MultiEntityResultTask
	GetTasksExecute(r ApiGetTasksRequest) (*MultiEntityResultTask, *http.Response, error)

	/*
		UpdateTask Update task

		Update a task by id.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to edit the containing page or blog post and view its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the task to be updated. If you don't know the task ID, use Get tasks and filter the results.
		@return ApiUpdateTaskRequest
	*/
	UpdateTask(ctx context.Context, id int64) ApiUpdateTaskRequest

	// UpdateTaskExecute executes the request
	//  @return Task
	UpdateTaskExecute(r ApiUpdateTaskRequest) (*Task, *http.Response, error)
}

// TaskApiService TaskApi service
type TaskApiService service

type ApiGetTaskByIdRequest struct {
	ctx                   context.Context
	ApiService            TaskApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	serializeIdsAsStrings *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetTaskByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetTaskByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetTaskByIdRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetTaskByIdRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetTaskByIdRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.GetTaskByIdExecute(r)
}

/*
GetTaskById Get task by id

Returns a specific task.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the containing page or blog post and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the task to be returned. If you don't know the task ID, use Get tasks and filter the results.
	@return ApiGetTaskByIdRequest
*/
func (a *TaskApiService) GetTaskById(ctx context.Context, id int64) ApiGetTaskByIdRequest {
	return ApiGetTaskByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Task
func (a *TaskApiService) GetTaskByIdExecute(r ApiGetTaskByIdRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.GetTaskById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTasksRequest struct {
	ctx                   context.Context
	ApiService            TaskApi
	bodyFormat            *PrimaryBodyRepresentation
	includeBlankTasks     *bool
	status                *string
	taskId                *[]int64
	spaceId               *[]int64
	pageId                *[]int64
	blogpostId            *[]int64
	createdBy             *[]string
	assignedTo            *[]string
	completedBy           *[]string
	createdAtFrom         *int64
	createdAtTo           *int64
	dueAtFrom             *int64
	dueAtTo               *int64
	completedAtFrom       *int64
	completedAtTo         *int64
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetTasksRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetTasksRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Specifies whether to include blank tasks in the response. Defaults to &#x60;true&#x60;.
func (r ApiGetTasksRequest) IncludeBlankTasks(includeBlankTasks bool) ApiGetTasksRequest {
	r.includeBlankTasks = &includeBlankTasks
	return r
}

// Filters on the status of the task.
func (r ApiGetTasksRequest) Status(status string) ApiGetTasksRequest {
	r.status = &status
	return r
}

// Filters on task ID. Multiple IDs can be specified.
func (r ApiGetTasksRequest) TaskId(taskId []int64) ApiGetTasksRequest {
	r.taskId = &taskId
	return r
}

// Filters on the space ID of the task. Multiple IDs can be specified.
func (r ApiGetTasksRequest) SpaceId(spaceId []int64) ApiGetTasksRequest {
	r.spaceId = &spaceId
	return r
}

// Filters on the page ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.
func (r ApiGetTasksRequest) PageId(pageId []int64) ApiGetTasksRequest {
	r.pageId = &pageId
	return r
}

// Filters on the blog post ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.
func (r ApiGetTasksRequest) BlogpostId(blogpostId []int64) ApiGetTasksRequest {
	r.blogpostId = &blogpostId
	return r
}

// Filters on the Account ID of the user who created this task. Multiple IDs can be specified.
func (r ApiGetTasksRequest) CreatedBy(createdBy []string) ApiGetTasksRequest {
	r.createdBy = &createdBy
	return r
}

// Filters on the Account ID of the user to whom this task is assigned. Multiple IDs can be specified.
func (r ApiGetTasksRequest) AssignedTo(assignedTo []string) ApiGetTasksRequest {
	r.assignedTo = &assignedTo
	return r
}

// Filters on the Account ID of the user who completed this task. Multiple IDs can be specified.
func (r ApiGetTasksRequest) CompletedBy(completedBy []string) ApiGetTasksRequest {
	r.completedBy = &completedBy
	return r
}

// Filters on start of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.
func (r ApiGetTasksRequest) CreatedAtFrom(createdAtFrom int64) ApiGetTasksRequest {
	r.createdAtFrom = &createdAtFrom
	return r
}

// Filters on end of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.
func (r ApiGetTasksRequest) CreatedAtTo(createdAtTo int64) ApiGetTasksRequest {
	r.createdAtTo = &createdAtTo
	return r
}

// Filters on start of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.
func (r ApiGetTasksRequest) DueAtFrom(dueAtFrom int64) ApiGetTasksRequest {
	r.dueAtFrom = &dueAtFrom
	return r
}

// Filters on end of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.
func (r ApiGetTasksRequest) DueAtTo(dueAtTo int64) ApiGetTasksRequest {
	r.dueAtTo = &dueAtTo
	return r
}

// Filters on start of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.
func (r ApiGetTasksRequest) CompletedAtFrom(completedAtFrom int64) ApiGetTasksRequest {
	r.completedAtFrom = &completedAtFrom
	return r
}

// Filters on end of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.
func (r ApiGetTasksRequest) CompletedAtTo(completedAtTo int64) ApiGetTasksRequest {
	r.completedAtTo = &completedAtTo
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetTasksRequest) Cursor(cursor string) ApiGetTasksRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of tasks per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetTasksRequest) Limit(limit int32) ApiGetTasksRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetTasksRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetTasksRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetTasksRequest) Execute() (*MultiEntityResultTask, *http.Response, error) {
	return r.ApiService.GetTasksExecute(r)
}

/*
GetTasks Get tasks

Returns all tasks. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).
Only tasks that the user has permission to view will be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTasksRequest
*/
func (a *TaskApiService) GetTasks(ctx context.Context) ApiGetTasksRequest {
	return ApiGetTasksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultTask
func (a *TaskApiService) GetTasksExecute(r ApiGetTasksRequest) (*MultiEntityResultTask, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.GetTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.includeBlankTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include-blank-tasks", r.includeBlankTasks, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.taskId != nil {
		t := *r.taskId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "task-id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "task-id", t, "multi")
		}
	}
	if r.spaceId != nil {
		t := *r.spaceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space-id", t, "multi")
		}
	}
	if r.pageId != nil {
		t := *r.pageId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "page-id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "page-id", t, "multi")
		}
	}
	if r.blogpostId != nil {
		t := *r.blogpostId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "blogpost-id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "blogpost-id", t, "multi")
		}
	}
	if r.createdBy != nil {
		t := *r.createdBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created-by", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created-by", t, "multi")
		}
	}
	if r.assignedTo != nil {
		t := *r.assignedTo
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "assigned-to", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "assigned-to", t, "multi")
		}
	}
	if r.completedBy != nil {
		t := *r.completedBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "completed-by", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "completed-by", t, "multi")
		}
	}
	if r.createdAtFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created-at-from", r.createdAtFrom, "")
	}
	if r.createdAtTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created-at-to", r.createdAtTo, "")
	}
	if r.dueAtFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "due-at-from", r.dueAtFrom, "")
	}
	if r.dueAtTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "due-at-to", r.dueAtTo, "")
	}
	if r.completedAtFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed-at-from", r.completedAtFrom, "")
	}
	if r.completedAtTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "completed-at-to", r.completedAtTo, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTaskRequest struct {
	ctx                   context.Context
	ApiService            TaskApi
	id                    int64
	updateTaskRequest     *UpdateTaskRequest
	serializeIdsAsStrings *bool
}

func (r ApiUpdateTaskRequest) UpdateTaskRequest(updateTaskRequest UpdateTaskRequest) ApiUpdateTaskRequest {
	r.updateTaskRequest = &updateTaskRequest
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiUpdateTaskRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiUpdateTaskRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiUpdateTaskRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.UpdateTaskExecute(r)
}

/*
UpdateTask Update task

Update a task by id.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to edit the containing page or blog post and view its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the task to be updated. If you don't know the task ID, use Get tasks and filter the results.
	@return ApiUpdateTaskRequest
*/
func (a *TaskApiService) UpdateTask(ctx context.Context, id int64) ApiUpdateTaskRequest {
	return ApiUpdateTaskRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Task
func (a *TaskApiService) UpdateTaskExecute(r ApiUpdateTaskRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaskApiService.UpdateTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateTaskRequest == nil {
		return localVarReturnValue, nil, reportError("updateTaskRequest is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateTaskRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
