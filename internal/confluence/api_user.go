/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confluence

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type UserApi interface {

	/*
		CheckAccessByEmail Check site access for a list of emails

		Returns the list of emails from the input list that do not have access to site.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to access the Confluence site ('Can use' global permission).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCheckAccessByEmailRequest
	*/
	CheckAccessByEmail(ctx context.Context) ApiCheckAccessByEmailRequest

	// CheckAccessByEmailExecute executes the request
	//  @return CheckAccessByEmail200Response
	CheckAccessByEmailExecute(r ApiCheckAccessByEmailRequest) (*CheckAccessByEmail200Response, *http.Response, error)

	/*
		InviteByEmail Invite a list of emails to the site

		Invite a list of emails to the site.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to access the Confluence site ('Can use' global permission).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiInviteByEmailRequest
	*/
	InviteByEmail(ctx context.Context) ApiInviteByEmailRequest

	// InviteByEmailExecute executes the request
	//  @return InviteByEmail200Response
	InviteByEmailExecute(r ApiInviteByEmailRequest) (*InviteByEmail200Response, *http.Response, error)
}

// UserApiService UserApi service
type UserApiService service

type ApiCheckAccessByEmailRequest struct {
	ctx                       context.Context
	ApiService                UserApi
	checkAccessByEmailRequest *CheckAccessByEmailRequest
}

func (r ApiCheckAccessByEmailRequest) CheckAccessByEmailRequest(checkAccessByEmailRequest CheckAccessByEmailRequest) ApiCheckAccessByEmailRequest {
	r.checkAccessByEmailRequest = &checkAccessByEmailRequest
	return r
}

func (r ApiCheckAccessByEmailRequest) Execute() (*CheckAccessByEmail200Response, *http.Response, error) {
	return r.ApiService.CheckAccessByEmailExecute(r)
}

/*
CheckAccessByEmail Check site access for a list of emails

Returns the list of emails from the input list that do not have access to site.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCheckAccessByEmailRequest
*/
func (a *UserApiService) CheckAccessByEmail(ctx context.Context) ApiCheckAccessByEmailRequest {
	return ApiCheckAccessByEmailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CheckAccessByEmail200Response
func (a *UserApiService) CheckAccessByEmailExecute(r ApiCheckAccessByEmailRequest) (*CheckAccessByEmail200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CheckAccessByEmail200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.CheckAccessByEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/access/check-access-by-email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.checkAccessByEmailRequest == nil {
		return localVarReturnValue, nil, reportError("checkAccessByEmailRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.checkAccessByEmailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInviteByEmailRequest struct {
	ctx                       context.Context
	ApiService                UserApi
	checkAccessByEmailRequest *CheckAccessByEmailRequest
}

func (r ApiInviteByEmailRequest) CheckAccessByEmailRequest(checkAccessByEmailRequest CheckAccessByEmailRequest) ApiInviteByEmailRequest {
	r.checkAccessByEmailRequest = &checkAccessByEmailRequest
	return r
}

func (r ApiInviteByEmailRequest) Execute() (*InviteByEmail200Response, *http.Response, error) {
	return r.ApiService.InviteByEmailExecute(r)
}

/*
InviteByEmail Invite a list of emails to the site

Invite a list of emails to the site.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInviteByEmailRequest
*/
func (a *UserApiService) InviteByEmail(ctx context.Context) ApiInviteByEmailRequest {
	return ApiInviteByEmailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return InviteByEmail200Response
func (a *UserApiService) InviteByEmailExecute(r ApiInviteByEmailRequest) (*InviteByEmail200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InviteByEmail200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserApiService.InviteByEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/access/invite-by-email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.checkAccessByEmailRequest == nil {
		return localVarReturnValue, nil, reportError("checkAccessByEmailRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.checkAccessByEmailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
