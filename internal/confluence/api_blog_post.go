/*
The Confluence Cloud REST API v2

This document describes Confluence's v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package confluence

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type BlogPostApi interface {

	/*
		CreateBlogPost Create blog post

		Creates a new blog post in the space specified by the spaceId.

	By default this will create the blog post as a non-draft, unless the status is specified as draft.
	If creating a non-draft, the title must not be empty.

	Currently only supports the storage representation specified in the body.representation enums below

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateBlogPostRequest
	*/
	CreateBlogPost(ctx context.Context) ApiCreateBlogPostRequest

	// CreateBlogPostExecute executes the request
	//  @return BlogPost
	CreateBlogPostExecute(r ApiCreateBlogPostRequest) (*BlogPost, *http.Response, error)

	/*
		DeleteBlogPost Delete blog post

		Delete a blog post by id.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the blog post and its corresponding space. Permission to delete blog posts in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the blog post to be deleted.
		@return ApiDeleteBlogPostRequest
	*/
	DeleteBlogPost(ctx context.Context, id int64) ApiDeleteBlogPostRequest

	// DeleteBlogPostExecute executes the request
	DeleteBlogPostExecute(r ApiDeleteBlogPostRequest) (*http.Response, error)

	/*
		GetBlogPostById Get blog post by id

		Returns a specific blog post.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the blog post and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the blog post to be returned. If you don't know the blog post ID, use Get blog posts and filter the results.
		@return ApiGetBlogPostByIdRequest
	*/
	GetBlogPostById(ctx context.Context, id int64) ApiGetBlogPostByIdRequest

	// GetBlogPostByIdExecute executes the request
	//  @return BlogPost
	GetBlogPostByIdExecute(r ApiGetBlogPostByIdRequest) (*BlogPost, *http.Response, error)

	/*
		GetBlogPosts Get blog posts

		Returns all blog posts. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to access the Confluence site ('Can use' global permission).
	Only blog posts that the user has permission to view will be returned.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetBlogPostsRequest
	*/
	GetBlogPosts(ctx context.Context) ApiGetBlogPostsRequest

	// GetBlogPostsExecute executes the request
	//  @return MultiEntityResultBlogPost
	GetBlogPostsExecute(r ApiGetBlogPostsRequest) (*MultiEntityResultBlogPost, *http.Response, error)

	/*
		GetBlogPostsInSpace Get blog posts in space

		Returns all blog posts in a space. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to access the Confluence site ('Can use' global permission) and view the space.
	Only blog posts that the user has permission to view will be returned.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the space for which blog posts should be returned.
		@return ApiGetBlogPostsInSpaceRequest
	*/
	GetBlogPostsInSpace(ctx context.Context, id int64) ApiGetBlogPostsInSpaceRequest

	// GetBlogPostsInSpaceExecute executes the request
	//  @return MultiEntityResultBlogPost
	GetBlogPostsInSpaceExecute(r ApiGetBlogPostsInSpaceRequest) (*MultiEntityResultBlogPost, *http.Response, error)

	/*
		GetLabelBlogPosts Get blog posts for label

		Returns the blogposts of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
	will be available through the `next` URL present in the `Link` response header.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the content of the page and its corresponding space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the label for which blog posts should be returned.
		@return ApiGetLabelBlogPostsRequest
	*/
	GetLabelBlogPosts(ctx context.Context, id int64) ApiGetLabelBlogPostsRequest

	// GetLabelBlogPostsExecute executes the request
	//  @return MultiEntityResultBlogPost
	GetLabelBlogPostsExecute(r ApiGetLabelBlogPostsRequest) (*MultiEntityResultBlogPost, *http.Response, error)

	/*
		UpdateBlogPost Update blog post

		Update a blog post by id.

	**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
	Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the blog post to be updated. If you don't know the blog post ID, use Get Blog Posts and filter the results.
		@return ApiUpdateBlogPostRequest
	*/
	UpdateBlogPost(ctx context.Context, id int64) ApiUpdateBlogPostRequest

	// UpdateBlogPostExecute executes the request
	//  @return BlogPost
	UpdateBlogPostExecute(r ApiUpdateBlogPostRequest) (*BlogPost, *http.Response, error)
}

// BlogPostApiService BlogPostApi service
type BlogPostApiService service

type ApiCreateBlogPostRequest struct {
	ctx                   context.Context
	ApiService            BlogPostApi
	createBlogPostRequest *CreateBlogPostRequest
	serializeIdsAsStrings *bool
}

func (r ApiCreateBlogPostRequest) CreateBlogPostRequest(createBlogPostRequest CreateBlogPostRequest) ApiCreateBlogPostRequest {
	r.createBlogPostRequest = &createBlogPostRequest
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiCreateBlogPostRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiCreateBlogPostRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiCreateBlogPostRequest) Execute() (*BlogPost, *http.Response, error) {
	return r.ApiService.CreateBlogPostExecute(r)
}

/*
CreateBlogPost Create blog post

Creates a new blog post in the space specified by the spaceId.

By default this will create the blog post as a non-draft, unless the status is specified as draft.
If creating a non-draft, the title must not be empty.

Currently only supports the storage representation specified in the body.representation enums below

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateBlogPostRequest
*/
func (a *BlogPostApiService) CreateBlogPost(ctx context.Context) ApiCreateBlogPostRequest {
	return ApiCreateBlogPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BlogPost
func (a *BlogPostApiService) CreateBlogPostExecute(r ApiCreateBlogPostRequest) (*BlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.CreateBlogPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createBlogPostRequest == nil {
		return localVarReturnValue, nil, reportError("createBlogPostRequest is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBlogPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlogPostRequest struct {
	ctx        context.Context
	ApiService BlogPostApi
	id         int64
}

func (r ApiDeleteBlogPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBlogPostExecute(r)
}

/*
DeleteBlogPost Delete blog post

Delete a blog post by id.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post and its corresponding space. Permission to delete blog posts in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the blog post to be deleted.
	@return ApiDeleteBlogPostRequest
*/
func (a *BlogPostApiService) DeleteBlogPost(ctx context.Context, id int64) ApiDeleteBlogPostRequest {
	return ApiDeleteBlogPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *BlogPostApiService) DeleteBlogPostExecute(r ApiDeleteBlogPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.DeleteBlogPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBlogPostByIdRequest struct {
	ctx                   context.Context
	ApiService            BlogPostApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	getDraft              *bool
	version               *int32
	serializeIdsAsStrings *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostByIdRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostByIdRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Retrieve the draft version of this blog post.
func (r ApiGetBlogPostByIdRequest) GetDraft(getDraft bool) ApiGetBlogPostByIdRequest {
	r.getDraft = &getDraft
	return r
}

// Allows you to retrieve a previously published version. Specify the previous version&#39;s number to retrieve its details.
func (r ApiGetBlogPostByIdRequest) Version(version int32) ApiGetBlogPostByIdRequest {
	r.version = &version
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetBlogPostByIdRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetBlogPostByIdRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetBlogPostByIdRequest) Execute() (*BlogPost, *http.Response, error) {
	return r.ApiService.GetBlogPostByIdExecute(r)
}

/*
GetBlogPostById Get blog post by id

Returns a specific blog post.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the blog post to be returned. If you don't know the blog post ID, use Get blog posts and filter the results.
	@return ApiGetBlogPostByIdRequest
*/
func (a *BlogPostApiService) GetBlogPostById(ctx context.Context, id int64) ApiGetBlogPostByIdRequest {
	return ApiGetBlogPostByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BlogPost
func (a *BlogPostApiService) GetBlogPostByIdExecute(r ApiGetBlogPostByIdRequest) (*BlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetBlogPostById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.getDraft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "get-draft", r.getDraft, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostsRequest struct {
	ctx                   context.Context
	ApiService            BlogPostApi
	id                    *[]int64
	status                *string
	bodyFormat            *PrimaryBodyRepresentation
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// Filter the results based on blog post ids. Multiple blog post ids can be specified as a comma-separated list.
func (r ApiGetBlogPostsRequest) Id(id []int64) ApiGetBlogPostsRequest {
	r.id = &id
	return r
}

// Filter the results to blog posts based on their status.
func (r ApiGetBlogPostsRequest) Status(status string) ApiGetBlogPostsRequest {
	r.status = &status
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostsRequest) Cursor(cursor string) ApiGetBlogPostsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; response header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostsRequest) Limit(limit int32) ApiGetBlogPostsRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetBlogPostsRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetBlogPostsRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetBlogPostsRequest) Execute() (*MultiEntityResultBlogPost, *http.Response, error) {
	return r.ApiService.GetBlogPostsExecute(r)
}

/*
GetBlogPosts Get blog posts

Returns all blog posts. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission).
Only blog posts that the user has permission to view will be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBlogPostsRequest
*/
func (a *BlogPostApiService) GetBlogPosts(ctx context.Context) ApiGetBlogPostsRequest {
	return ApiGetBlogPostsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultBlogPost
func (a *BlogPostApiService) GetBlogPostsExecute(r ApiGetBlogPostsRequest) (*MultiEntityResultBlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetBlogPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		t := *r.id
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "id", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "id", t, "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlogPostsInSpaceRequest struct {
	ctx                   context.Context
	ApiService            BlogPostApi
	id                    int64
	status                *string
	bodyFormat            *PrimaryBodyRepresentation
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// Filter the results to blog posts based on their status.
func (r ApiGetBlogPostsInSpaceRequest) Status(status string) ApiGetBlogPostsInSpaceRequest {
	r.status = &status
	return r
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetBlogPostsInSpaceRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetBlogPostsInSpaceRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetBlogPostsInSpaceRequest) Cursor(cursor string) ApiGetBlogPostsInSpaceRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetBlogPostsInSpaceRequest) Limit(limit int32) ApiGetBlogPostsInSpaceRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetBlogPostsInSpaceRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetBlogPostsInSpaceRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetBlogPostsInSpaceRequest) Execute() (*MultiEntityResultBlogPost, *http.Response, error) {
	return r.ApiService.GetBlogPostsInSpaceExecute(r)
}

/*
GetBlogPostsInSpace Get blog posts in space

Returns all blog posts in a space. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to access the Confluence site ('Can use' global permission) and view the space.
Only blog posts that the user has permission to view will be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the space for which blog posts should be returned.
	@return ApiGetBlogPostsInSpaceRequest
*/
func (a *BlogPostApiService) GetBlogPostsInSpace(ctx context.Context, id int64) ApiGetBlogPostsInSpaceRequest {
	return ApiGetBlogPostsInSpaceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultBlogPost
func (a *BlogPostApiService) GetBlogPostsInSpaceExecute(r ApiGetBlogPostsInSpaceRequest) (*MultiEntityResultBlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetBlogPostsInSpace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spaces/{id}/blogposts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLabelBlogPostsRequest struct {
	ctx                   context.Context
	ApiService            BlogPostApi
	id                    int64
	bodyFormat            *PrimaryBodyRepresentation
	sort                  *BlogPostSortOrder
	cursor                *string
	limit                 *int32
	serializeIdsAsStrings *bool
}

// The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
func (r ApiGetLabelBlogPostsRequest) BodyFormat(bodyFormat PrimaryBodyRepresentation) ApiGetLabelBlogPostsRequest {
	r.bodyFormat = &bodyFormat
	return r
}

// Used to sort the result by a particular field.
func (r ApiGetLabelBlogPostsRequest) Sort(sort BlogPostSortOrder) ApiGetLabelBlogPostsRequest {
	r.sort = &sort
	return r
}

// Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
func (r ApiGetLabelBlogPostsRequest) Cursor(cursor string) ApiGetLabelBlogPostsRequest {
	r.cursor = &cursor
	return r
}

// Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
func (r ApiGetLabelBlogPostsRequest) Limit(limit int32) ApiGetLabelBlogPostsRequest {
	r.limit = &limit
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiGetLabelBlogPostsRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiGetLabelBlogPostsRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiGetLabelBlogPostsRequest) Execute() (*MultiEntityResultBlogPost, *http.Response, error) {
	return r.ApiService.GetLabelBlogPostsExecute(r)
}

/*
GetLabelBlogPosts Get blog posts for label

Returns the blogposts of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
will be available through the `next` URL present in the `Link` response header.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the content of the page and its corresponding space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the label for which blog posts should be returned.
	@return ApiGetLabelBlogPostsRequest
*/
func (a *BlogPostApiService) GetLabelBlogPosts(ctx context.Context, id int64) ApiGetLabelBlogPostsRequest {
	return ApiGetLabelBlogPostsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return MultiEntityResultBlogPost
func (a *BlogPostApiService) GetLabelBlogPostsExecute(r ApiGetLabelBlogPostsRequest) (*MultiEntityResultBlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MultiEntityResultBlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.GetLabelBlogPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/labels/{id}/blogposts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bodyFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "body-format", r.bodyFormat, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBlogPostRequest struct {
	ctx                   context.Context
	ApiService            BlogPostApi
	id                    int64
	updateBlogPostRequest *UpdateBlogPostRequest
	serializeIdsAsStrings *bool
}

func (r ApiUpdateBlogPostRequest) UpdateBlogPostRequest(updateBlogPostRequest UpdateBlogPostRequest) ApiUpdateBlogPostRequest {
	r.updateBlogPostRequest = &updateBlogPostRequest
	return r
}

// Due to JavaScript&#39;s max integer representation of 2^53-1, the type of any IDs returned in the response body for this endpoint will be changed from a numeric type to a string type at the end of the deprecation period. In the meantime, this query param can be passed to this endpoint to opt-in to this change now. See this [changelog](https://developer.atlassian.com/cloud/confluence/changelog/#CHANGE-905) for more detail.
func (r ApiUpdateBlogPostRequest) SerializeIdsAsStrings(serializeIdsAsStrings bool) ApiUpdateBlogPostRequest {
	r.serializeIdsAsStrings = &serializeIdsAsStrings
	return r
}

func (r ApiUpdateBlogPostRequest) Execute() (*BlogPost, *http.Response, error) {
	return r.ApiService.UpdateBlogPostExecute(r)
}

/*
UpdateBlogPost Update blog post

Update a blog post by id.

**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the blog post to be updated. If you don't know the blog post ID, use Get Blog Posts and filter the results.
	@return ApiUpdateBlogPostRequest
*/
func (a *BlogPostApiService) UpdateBlogPost(ctx context.Context, id int64) ApiUpdateBlogPostRequest {
	return ApiUpdateBlogPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return BlogPost
func (a *BlogPostApiService) UpdateBlogPostExecute(r ApiUpdateBlogPostRequest) (*BlogPost, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlogPost
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogPostApiService.UpdateBlogPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/blogposts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateBlogPostRequest == nil {
		return localVarReturnValue, nil, reportError("updateBlogPostRequest is required and must be specified")
	}

	if r.serializeIdsAsStrings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serialize-ids-as-strings", r.serializeIdsAsStrings, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateBlogPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
